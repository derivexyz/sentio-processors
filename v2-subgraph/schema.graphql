type BalanceAdjusted @entity(immutable: true) {
  id: Bytes!
  subaccount: SubAccount!
  asset: Asset!
  accountId: BigInt! # uint256
  manager: Bytes! # address
  amount: BigDecimal! # int256
  preBalance: BigDecimal! # int256
  postBalance: BigDecimal! # int256
  tradeId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SubAccount @entity {
  id: String!
  subaccountId: BigInt!
  owner: Account! # The current owner of this subaccount
  matchingOwner: Account # Only populated if this is owned by the matching contract
  balances: [SubAccountBalance!]! @derivedFrom(field: "subaccount")
  balanceAdjustments: [BalanceAdjusted!]! @derivedFrom(field: "subaccount")
}

type Account @entity {
  id: Bytes!
  owner: Bytes # If a LightAccount
  subaccounts: [SubAccount!]! @derivedFrom(field: "owner")
  depositedSubaccounts: [SubAccount!]! @derivedFrom(field: "matchingOwner")
}

type SubAccountBalance @entity {
  id: String! # Composite key: subaccount + asset
  subaccount: SubAccount!
  asset: Asset!
  balance: BigDecimal! # int256
  lastUpdated: BigInt! # timestamp
}

type Asset @entity {
  id: Bytes! # bytes32 (assetAndSubId)
  assetContract: AssetContract!
  subId: BigInt!
  name: String!
  expiry: BigInt
  strike: Int
  isCall: Boolean
  balances: [SubAccountBalance!]! @derivedFrom(field: "asset")
  balanceAdjustments: [BalanceAdjusted!]! @derivedFrom(field: "asset")
}


enum AssetType {
  Option
  Perp
  Spot
  Unknown
}

type AssetContract @entity {
  id: String!
  address: String!
  currency: Currency!
  assetType: AssetType!
}

type Currency @entity {
  id: String!
}